# Журнал промптов к AI для создания алгоритмов воркера укладки графа

Сюда в обязательном порядке нужно сохранять все запросы к нейросети для получения какого либо алгоритма, без ответов модели. Нейросети нельзя изменять этот файл, но обязательно сообщать добавлять сюда введённый промпт. Для этого можно использовать функцию экспортирования чата в Cursor.

## Распределённый алгоритм укладки графа. Обобщение оригинальных промптов

Должно обязательно учитываться в алгоритме:
- Основание для разработки: Windows (хост где ведётся разработка), PowerShell, WSL, микросервисная архитектура, Docker, Docker Compose, Git, VS Code (Cursor IDE), Neo4j, Cypher, Python, Poetry.
- Промышленный и профессиональный подход.
- Оптимизация в Big O нотации. Выбираются самые производительные решения. Главное скорость, можно пожертвовать памятью и размерами хранилища.
- Можно рассматривать гибридные решения если они производительнее.
- Выдавать сразу правильный код без ошибок линтинга.
- По возможности выдавать сразу правильное решение, что бы не делать несколько итераций улучшения.
- Проверка на ошибки.
- Ведение подробных логов для быстрого выявления ошибок.
- Наш граф всегда должен оставаться DAG, направленным ациклическим графом. Нужна проверка на ацикличность и её исправления если есть циклы.
- Укладка DAG графа.
- Выполнение операций на стороне базы данных в приоритете над операциями в коде.
- Асинхронность.
- Распределённость.
- Научные статьи будут отображаются в виде визуальных блоков с надписью, где написана строчка в формате "PMID - Название статьи".
- Визуальные блоки статей не должны накладываться друг на друга или пересекаться.
- На выбор модели инкрементальная или батчевая укладка.
- Топологическая сортировка всего графа в начале.
- После топологической сортировки, сначала находится и укладывается longest path (LP). LP размещается на нулевом уровне, а каждый следующий (топологически) его блок на уникальном слое. Затем остальной граф имеющий связи с LP, это будет первая компонента связности, затем нужно уложить все остальные блоки и компонты связности.
- Нельзя пользоваться: pip, файлом requirements.txt.
- Нельзя запускать клиент. Я буду это делать сам.
- Запрещаю создавать `*.bat` и `*ps1` файлы.
- Мы в базе данных и в коде работаем с `:Article`, а не `:Node`, `vertex`, `nodes` и тому подобным. Нужно использовать Article для БД, а не Node. Если в БД есть Node, нужно переделать их на Article.
- Загрузка блоков (Block) и загрузка статей (Article) это разные вещи, не одно и тоже, это разные подпроекты.
- Вместо списка отдельных запросов к БД и поочрёдного выполнения в Python цикле, нужно делать всё в одном запросе, при этом сохраняя очерёдность их выполнения.
- Не используй рекурсию
- Не используй бесконечные циклы `while True`, вместо этого прописывай явные условния и защиту от бесконечных циклов.
- Longest path (LP) нужно укладывать топологически.
- Граф не должен иметь петель.
- Граф не должен иметь несколько вершин между одной и тойже пары блоков.
- API вообще не должен никак изменять координаты. Только передавать на клиент.
- Не нужно никаких расчётов "от центра" для укладки. У LP собственная укладка, у остальных вершин собственная укладка, но не одна из них не по координатам в своей основе, а по слоям и уровням, так что привычного "центра" в графе нет. Укладка должна быть по топологии в первую очередь. Но сейчас мы работаем только с LP.
- Я сам буду запускать и перезапускать Docker сервисы/контейнеры. Просто сообщай что мне нужно это сделать.
- Компонентов связности может быть неограниченное количество.
- Запрещено располагать блоки на одни и те же места (уникальная комбинация уровня и слоя) и соответственно координаты.
- После укладки LP нужно располагать блоки "вокруг" LP той же компоненте связности, топологически на ближайшее место, от связанного с ним блока-потомка, если место занято, то можно переместить такую вершину на свободное место в этом слое. Остальные блоки позиционируются так же, хоть и нет связей с другими компонентами связности.
- Размещение соседей longest path должно быть топологическим. Каждый блок должен быть как минимум на один слой впереди от своего предка, и на один слой сзади от своего потомка, а не на томже слое. Если понадобиться то сдвигай необходимые LP вершины вправо инкрементально (как только появится необходимость). Соответсвтенно если одна вершина сдвинута вправо то и все следущие после неё тоже должны сместиться на слой вправо (и не забыть пересчитать координаты)
- Укладка LP, соседей LP и остальных блоков это три отдельных укладки, и каждая следующая не должна влиять на предыдущую, кроме смещения вперёд по слоям блоков предыдущих укладок.
- Подумай про ошибки которые можешь допустить, что бы не получилось ошибок и аномальных значений.
- В коде старайся очищать память после операций если это необходимо.
- Статьи должны укладываться в хронологическом порядке слева направо.
- Блоки статьи должны распологаться по топологической расстановке (можно по сетке) и инкрементальным алгоритмом для того что бы память не переполнялась всем графом разом. На одном месте не должно быть несколько блоков, для каждого блока отдельное место без дополнительных смещений координат, должно быть чётко по уровням и слоям.
- Подгрузка вершин на клиенте при пагинации дожна загружать только те блоки которые попадают в окно просмотра. То есть проецировать границы окна просмотра, на мировые координаты. Получается нужно отфильтровывать блоки которые не будут показаны по координатам полученной рамки.
- После топологической сортировки порядок отсортированных числел должен быть — монотонно неубывающей последовательностью целых чисел без пропусков

## Алгоритм укладки Карты Знаний

- Загрузить данные, проверяя их целостность.
- Выявить всевозможные структуры документов и обобщить, что бы всегда находился PMID статьи и её библиографические ссылки. 
- Проверить что попало в БД (по распределениям данных).

1. Получить направленный граф зависимостей научных статей друго от друга по библиографическим ссылкам.
2. Убрать петли из графа.
3. Убрать повторяющиеся рёбра между одной и тойже парой вершин. Между парой вершин должно быть только одно ребро.
4. Преобразовать граф в направленный ациклический граф (DAG) методом разворота минимального количества рёбер.
   1. Отдельным тестом проверить граф на ацикличность. Если истина, значит алгоритм корректный.
5. Применить к DAG топологическую сортировку.
   1. Отдельным тестом проверить алгоритм, является ли полученная топологическая сортировка набором чисел монотонно неубывающей последовательностью целых чисел без пропусков. Если истина, значит алгоритм корректный.
6. Найти 1 длиннейший путь в графе.
7. Назначить узлам длиннейшего пути (longest path (LP)) нулевой уровень (level)
8. Назначить узлам длиннейшего пути слои начиная с нулевого слоя (layer) и назначая следующий слой каждой следующей вершине.

- Визуальный блок или просто "блок" это графическое отображение вершин при визуализации с шириной, высотой, надписью и координатами.
- Блокам присваиваются координаты по оси x на основе его слоя, учитывая ширину блока и горизонтальный отступ от блоков соседних слоёв.
- Блокам присваиваются координаты по оси y на основе его уровня, учитывая высоту визуального блока и вертикальный отступ от блоков соседних уровней.
- Таким образом граф укладывается слева направо, где по горизонтали распределяются слои, а по вертикали уровни.
- На одном слое может находиться неограниченное количество вершин.
- Уровни могут быть отрицательными.
- Закреплённые вершины сохраняют назначенные им уровни при переукладке, но могут менять слой.
- Место это уникальная пара слой и уровень.
- На одном месте может находиться только одна вершина.
- Если в данной статье есть библиографические ссылки, то нужно принять их так же за статьи, а также за хронологически более старые статьи. А данную статью за хронологически более новую относительно них. Таким образом граф должен топологически укладываться слева направо единым однонаправленным DAG потоком, где слева более старые, а справа более новые научные статьи.

## Оригиналы промптов (новые сверху, нейросети не нужно читать далее и помещать это в контекст)

Шаблон
> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> 2025.09.08 15:28:04  
> На @client/ нужно проверить как подгружаются вершины относительно окна просмотра. Нужно что бы грузились только блоки которые попали в окно просмотра и немного за его пределы, отфильтровывая по координатам x и y, Получается что нужно спроицировать границы окна просмотра на мировые координаты холста, затем относительно полученных координат фильтровать блоки которые которые не входят в окно просмотра, и показывать те которые остались внутри.


> 2025.09.08 12:02:23  
> Хорошо, все остальные блоки статьи получили свои слои и уровни и соответствующие координаты. Но нужно удалить расстановку остальных блоков по радиусу и изменить на топологическую расстановку (можно по сетке) но инкрементальным алгоритмом для того что бы память не переполнялась всем графом разом. Так же в одной cell не должно быть несколько блоков, для каждого блока отдельная cell. 


> 2025.09.06 17:20:30  
> @longest_path.py  Я хочу что бы укладка длиннейшего пути была топологической вместо арифметической прогрессии. Подумай про ошибки которые можешь допустить, что бы не получилось итоговых координат с аномальными значениями.


> 2025.09.06 15:50:04  
> Размещение соседей longest path не до конца корректно, оно должно быть топологическим. Каждый блок должен быть как минимум на один слой впереди от своего предка, и на один слой сзади от своего потомка, а не на томже слое. Если понадобиться то сдвигай необходимые LP вершины вправо инкрементально (как только появится необходимость). Соответсвтенно если одна вершина сдвинута вправо то и все следущие после неё тоже должны сместиться на слой вправо (и не забыть пересчитать координаты)


> 2025.09.06 13:49:30  
> API вообще не должен никак изменять координаты. Только передавать на клиент.
> 
> И не нужно никаких расчётов "от центра" убери их. У LP собственная укладка, у остальных вершин собственная укладка, но не одна из низ не по координатам в своей основе, так что привычного "центра" там просто нет. По топологии должна быть в первую очередь. Но сейчас мы работаем только с LP.


> 2025.09.05 19:05:30  
> Можно ли объеденить функции поиска и расположения longest path: find_longest_path_neo4j, place_longest_path в одну функцию. Так не придётся передавать данные между ними через код туда-сюда.@longest_path.py @distributed_incremental_layout.py 

> 2025.01.27 12:20:00  
> @longest_path.py @prompts_ai_journal.md  
> @longest_path.py Можно ли ускорить функцию place_longest_path используя не цикл, а математику в виде формулы арифметической прогрессии для назначения координат (в частности x) сделав это на стороне БД?

> 2025.09.05 18:21:44  
> @distributed_incremental_layout.py @prompts_ai_journal.md  
> Алгоритм работает очень долго, пожалуйста попробуй использовать операции на стороне БД если это возможно. Оптимизируй алгоритмы текущих этапов, это поиск циклов и их устранение путём разворота направленных связей. Используй информацию из исследования ниже. Алгоритм должен работать несколько секунд, а текущий не справляется за минуты, что говорит об огромном запасе для оптимизации.

> 2025.09.05 16:05:00  
> Видимо ошибка с 77.2% при выполнении, была связана с тем что в графе был цикл. Есть ли в Neo4j функция нахождения и исправления циклов в графе? Если есть, то нужно перенести алгоритм на сторону БД, а не использовать networkx.

> 2025.09.05 15:40:00  
> Кажется ты забыл добавить шаг с проверкой и исправлением цикличности графа. Нам нужен только DAG, направленный ациклический граф. В @layout_algorithm.py есть вариант который ты можешь адаптировать под эту проблему.

> 2025.09.05 15:31:30  
> @utils.py Вижу бесконечный цикл `while True`, сделай его пожалуйста конечным с явными переменными. Возможно именно это место застревает на 77.2%. Надо это исправить


> 2025.09.05 15:10:00  
> @utils.py Возможно ли сделать все запросы функции `async def initialize_layout_tables(self):` одним запросом сохраняя очерёдность БД операций?

> 2025.09.05 15:05:00  
> Отображение в консоли "едет", нужно добавить перенос строки в соответствующих местах.

> 2025.09.05 15:00:00  
> В @distributed_incremental_layout.py закомментируй строки которые не относятся к 1 шагу (STEP), что бы "выключить" следующие этапы или если это лучше подойдёт для ручного тестирования возвращай релевантный результат после 1 шага.

> 2025.09.05 14:43:54  
> Клиент перестал загружать статьи и останавливается с надписью `Инициализация...`, нужно что бы статьи загружались, найди проблему и исправь. Загрузка блоков (Block) и загрузка статей (Article) это разные вещи, не одно и тоже, это разные подпроекты. Сечас мы работаем с Article, а Block не трогай.

> 2025.09.05 14:00:00  
> Переделай код @api/ и @client/ соответственно только там где БД соединяется с api, а api с клиентом, то есть цепочка БД-API-client. Остальные места не трогай.

> 2025.09.05 13:39:24  
> @worker_distributed_layering/  Переделай все места в воркере где используется с `:Node` на `:Article`. Например `"all_labels": ["Node"],` или `"node_count": 1000,`. То есть у нас не должно быть нод у нас статьи в БД и в коде.

> 2025.09.05 13:38:34  
> Существует ли Circuit Breaker не в самописном варианте а виде специализированной библиотеки? Где самописного кода будет поменьше.@circuit_breaker.py 


> 2025.09.05 12:30:13  
> @algorithms/ @prompts_ai_journal.md @README_REFACTORING.md  
> Текущая проблема алгоритма укладки в том что он останавливается где то у 77.2% и дальше не идёт, останавливается без ошибок, не завершает укладку до конца. И ещё основная проблема в том что ты и алгоритм совершенно не понимают как нужно уложить граф. По этому ты меня должен научить этому алгоритму по этапам и подэтапам начиная с начала и при этом выключив все остальные этапы и включать их по мере прохождения, что бы я после каждого этапа мог оценить и проверить результат, ты мне должен будешь сказать как это сделать.