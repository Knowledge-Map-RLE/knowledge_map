# Журнал промптов к AI для создания алгоритмов воркера укладки графа

Сюда в обязательном порядке нужно сохранять все запросы к нейросети для получения какого либо алгоритма, без ответов модели. Нейросети нельзя изменять этот файл, но обязательно сообщать добавлять сюда введённый промпт. Для этого можно использовать функцию экспортирования чата в Cursor.

## Распределённый алгоритм укладки графа. Обобщение оригинальных промптов

Должно обязательно учитываться в алгоритме:
- Основание для разработки: Windows (хост где ведётся разработка), PowerShell, WSL, микросервисная архитектура, Docker, Docker Compose, Git, VS Code (Cursor IDE), Neo4j, Cypher, Python, Poetry.
- Промышленный и профессиональный подход.
- Оптимизация в Big O нотации. Выбираются самые производительные решения. Главное скорость, можно пожертвовать памятью и размерами хранилища.
- Можно рассматривать гибридные решения если они производительнее.
- Выдавать сразу правильный код без ошибок линтинга.
- По возможности выдавать сразу правильное решение, что бы не делать несколько итераций улучшения.
- Проверка на ошибки.
- Ведение подробных логов для быстрого выявления ошибок.
- Наш граф всегда должен оставаться DAG, направленным ациклическим графом. Нужна проверка на ацикличность и её исправления если есть циклы.
- Укладка DAG графа.
- Выполнение операций на стороне базы данных в приоритете над операциями в коде.
- Асинхронность.
- Распределённость.
- Научные статьи будут отображаются в виде визуальных блоков с надписью, где написана строчка в формате "PMID - Название статьи".
- Визуальные блоки статей не должны накладываться друг на друга или пересекаться.
- На выбор модели инкрементальная или батчевая укладка.
- Топологическая сортировка всего графа в начале.
- После топологической сортировки, сначала находится и укладывается longest path (LP). LP размещается на нулевом уровне, а каждый следующий (топологически) его блок на уникальном слое. Затем остальной граф имеющий связи с LP, это будет первая компонента связности, затем нужно уложить все остальные блоки и компонты связности.
- Нельзя пользоваться: pip, файлом requirements.txt.
- Нельзя запускать клиент. Я буду это делать сам.
- Запрещаю создавать `*.bat` и `*ps1` файлы.
- Мы в базе данных и в коде работаем с `:Article`, а не `:Node`, `vertex`, `nodes` и тому подобным. Нужно использовать Article для БД, а не Node. Если в БД есть Node, нужно переделать их на Article.
- Загрузка блоков (Block) и загрузка статей (Article) это разные вещи, не одно и тоже, это разные подпроекты.
- Вместо списка отдельных запросов к БД и поочрёдного выполнения в Python цикле, нужно делать всё в одном запросе, при этом сохраняя очерёдность их выполнения.
- Не используй рекурсию
- Не используй бесконечные циклы `while True`, вместо этого прописывай явные условния и защиту от бесконечных циклов.
- Longest path (LP) нужно укладывать топологически.
- Граф не должен иметь петель.
- Граф не должен иметь несколько вершин между одной и тойже пары блоков.
- API вообще не должен никак изменять координаты. Только передавать на клиент.
- Не нужно никаких расчётов "от центра" для укладки. У LP собственная укладка, у остальных вершин собственная укладка, но не одна из них не по координатам в своей основе, а по слоям и уровням, так что привычного "центра" в графе нет. Укладка должна быть по топологии в первую очередь. Но сейчас мы работаем только с LP.
- Я сам буду запускать и перезапускать Docker сервисы/контейнеры. Просто сообщай что мне нужно это сделать.
- Компонентов связности может быть неограниченное количество.
- Запрещено располагать блоки на одни и те же места (уникальная комбинация уровня и слоя) и соответственно координаты.
- После укладки LP нужно располагать блоки "вокруг" LP той же компоненте связности, топологически на ближайшее место, от связанного с ним блока-потомка, если место занято, то можно переместить такую вершину на свободное место в этом слое. Остальные блоки позиционируются так же, хоть и нет связей с другими компонентами связности.
- Размещение соседей longest path должно быть топологическим. Каждый блок должен быть как минимум на один слой впереди от своего предка, и на один слой сзади от своего потомка, а не на томже слое. Если понадобиться то сдвигай необходимые LP вершины вправо инкрементально (как только появится необходимость). Соответсвтенно если одна вершина сдвинута вправо то и все следущие после неё тоже должны сместиться на слой вправо (и не забыть пересчитать координаты)
- Укладка LP, соседей LP и остальных блоков это три отдельных укладки, и каждая следующая не должна влиять на предыдущую, кроме смещения вперёд по слоям блоков предыдущих укладок.
- Подумай про ошибки которые можешь допустить, что бы не получилось ошибок и аномальных значений.
- В коде старайся очищать память после операций если это необходимо.
- Статьи должны укладываться в хронологическом порядке слева направо.


## Оригиналы промптов (новые сверху, нейросети не нужно читать далее и помещать это в контекст)

Шаблон
> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> Время  
> Текст


> 2025.09.06 17:20:30  
> @longest_path.py  Я хочу что бы укладка длиннейшего пути была топологической вместо арифметической прогрессии. Подумай про ошибки которые можешь допустить, что бы не получилось итоговых координат с аномальными значениями.


> 2025.09.06 15:50:04  
> Размещение соседей longest path не до конца корректно, оно должно быть топологическим. Каждый блок должен быть как минимум на один слой впереди от своего предка, и на один слой сзади от своего потомка, а не на томже слое. Если понадобиться то сдвигай необходимые LP вершины вправо инкрементально (как только появится необходимость). Соответсвтенно если одна вершина сдвинута вправо то и все следущие после неё тоже должны сместиться на слой вправо (и не забыть пересчитать координаты)


> 2025.09.06 13:49:30  
> API вообще не должен никак изменять координаты. Только передавать на клиент.
> 
> И не нужно никаких расчётов "от центра" убери их. У LP собственная укладка, у остальных вершин собственная укладка, но не одна из низ не по координатам в своей основе, так что привычного "центра" там просто нет. По топологии должна быть в первую очередь. Но сейчас мы работаем только с LP.


> 2025.09.05 19:05:30  
> Можно ли объеденить функции поиска и расположения longest path: find_longest_path_neo4j, place_longest_path в одну функцию. Так не придётся передавать данные между ними через код туда-сюда.@longest_path.py @distributed_incremental_layout.py 

> 2025.01.27 12:20:00  
> @longest_path.py @prompts_ai_journal.md  
> @longest_path.py Можно ли ускорить функцию place_longest_path используя не цикл, а математику в виде формулы арифметической прогрессии для назначения координат (в частности x) сделав это на стороне БД?

> 2025.09.05 18:21:44  
> @distributed_incremental_layout.py @prompts_ai_journal.md  
> Алгоритм работает очень долго, пожалуйста попробуй использовать операции на стороне БД если это возможно. Оптимизируй алгоритмы текущих этапов, это поиск циклов и их устранение путём разворота направленных связей. Используй информацию из исследования ниже. Алгоритм должен работать несколько секунд, а текущий не справляется за минуты, что говорит об огромном запасе для оптимизации.

> 2025.09.05 16:05:00  
> Видимо ошибка с 77.2% при выполнении, была связана с тем что в графе был цикл. Есть ли в Neo4j функция нахождения и исправления циклов в графе? Если есть, то нужно перенести алгоритм на сторону БД, а не использовать networkx.

> 2025.09.05 15:40:00  
> Кажется ты забыл добавить шаг с проверкой и исправлением цикличности графа. Нам нужен только DAG, направленный ациклический граф. В @layout_algorithm.py есть вариант который ты можешь адаптировать под эту проблему.

> 2025.09.05 15:31:30  
> @utils.py Вижу бесконечный цикл `while True`, сделай его пожалуйста конечным с явными переменными. Возможно именно это место застревает на 77.2%. Надо это исправить


> 2025.09.05 15:10:00  
> @utils.py Возможно ли сделать все запросы функции `async def initialize_layout_tables(self):` одним запросом сохраняя очерёдность БД операций?

> 2025.09.05 15:05:00  
> Отображение в консоли "едет", нужно добавить перенос строки в соответствующих местах.

> 2025.09.05 15:00:00  
> В @distributed_incremental_layout.py закомментируй строки которые не относятся к 1 шагу (STEP), что бы "выключить" следующие этапы или если это лучше подойдёт для ручного тестирования возвращай релевантный результат после 1 шага.

> 2025.09.05 14:43:54  
> Клиент перестал загружать статьи и останавливается с надписью `Инициализация...`, нужно что бы статьи загружались, найди проблему и исправь. Загрузка блоков (Block) и загрузка статей (Article) это разные вещи, не одно и тоже, это разные подпроекты. Сечас мы работаем с Article, а Block не трогай.

> 2025.09.05 14:00:00  
> Переделай код @api/ и @client/ соответственно только там где БД соединяется с api, а api с клиентом, то есть цепочка БД-API-client. Остальные места не трогай.

> 2025.09.05 13:39:24  
> @worker_distributed_layering/  Переделай все места в воркере где используется с `:Node` на `:Article`. Например `"all_labels": ["Node"],` или `"node_count": 1000,`. То есть у нас не должно быть нод у нас статьи в БД и в коде.

> 2025.09.05 13:38:34  
> Существует ли Circuit Breaker не в самописном варианте а виде специализированной библиотеки? Где самописного кода будет поменьше.@circuit_breaker.py 


> 2025.09.05 12:30:13  
> @algorithms/ @prompts_ai_journal.md @README_REFACTORING.md  
> Текущая проблема алгоритма укладки в том что он останавливается где то у 77.2% и дальше не идёт, останавливается без ошибок, не завершает укладку до конца. И ещё основная проблема в том что ты и алгоритм совершенно не понимают как нужно уложить граф. По этому ты меня должен научить этому алгоритму по этапам и подэтапам начиная с начала и при этом выключив все остальные этапы и включать их по мере прохождения, что бы я после каждого этапа мог оценить и проверить результат, ты мне должен будешь сказать как это сделать.